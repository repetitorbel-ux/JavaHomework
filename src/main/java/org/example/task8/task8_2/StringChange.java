package org.example.task8.task8_2;

public class StringChange {
    public StringChange() {
    }

    String mySubStr = "XX"; //Строка для вставки
    public String changeString(int k, String strPar) {
        String newTextResult = ""; //Инициализация "пустой" переменной (ссылки на объект класса String), куда будет накапливаться результат ("сборщик 1")

        //Делим строку на части (слова) по пробелам (split(" ")) и возвращаем массив этих слов
        String[] newText = strPar.split(" ");

        for (String word : newText) { //проходим циклом (for-each) по каждому слову в массиве
            int lengthWord = word.length(); //Вычисление длины каждого слова в массиве
            int step = k + 1; //Вычисляем шаг цикла: например, для k=2 означает, что нас интересуют символы с индексами 0, 1, 2

            if (lengthWord < step) { //проверка длины слова: если меньше шага, не добавляем подстроку mySubStr
                newTextResult = newTextResult + word + " "; //добавление это слова в "сборщик 1"
            } else {
                String modifiedWord = ""; // Сборщик 2 для измененных слов (поделенных на куски равные step), которые длиннее или равны шагу 'step'
                for (int j = 0; j < word.length(); j += step) { //Цикл, который "режет" длинные слова на куски равные step

                    //Решение проблемы выхода за пределы слова, когда его остаток меньше шага (когда длина слова не кратна step)
                    String pieceOfWord; //1.Объявление переменной для хранения частей слова

                    if (j + step <= word.length()) {//2 Проверка возможности отступить на step символов от текущего места 'j'
                        pieceOfWord = word.substring(j, j + step);// 2.1 Если да, то отрезаем ровный кусок слова с записью в pieceOfWord
                    } else {
                        pieceOfWord = word.substring(j);// 2.2 Если нет, то это "хвостик" слова - берем все до конца (остаток слова не кратный step).
                    }

                    modifiedWord = modifiedWord + pieceOfWord;// Добавляем сам кусок слова в сборщик 2

                    // Если кусочек слова получился полным (его длина равна step), добавляем после него mySubStr и записываем все в modifiedWord
                    if (pieceOfWord.length() == step) {
                        modifiedWord = modifiedWord + mySubStr;
                    }
                }
                newTextResult = newTextResult + modifiedWord + " "; //Накопление измененных и неизменных слов в сборщике 1
            }
        }return newTextResult;
    }
}
/* Алгоритм общий
Берем строку и делим ее на отдельные слова и создаем массив из этих слов с помощью split().
Так как длина слов разная то нужна проверка.
Сначала вычисляем шаг для заданного k, затем делаем проверку: если слово меньше этого шага, то никаких действий с ним делать не нужно, просто добавляем это слово в конечную строку как есть.
Если слово длинное (больше этого шага), мы начинаем "нарезать" его на равные кусочки (длина кусочка = шагу). После каждого полного кусочка сразу добавляем нашу подстроку.
Так как длина слов может быть кратной и не кратной вычисленному шагу, то остается "хвостик".
Этот "хвостик" просто присоединяем без подстановки подстроки.
 */